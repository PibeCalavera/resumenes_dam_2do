<!DOCTYPE html>

<html lang="es" xml:lang="es">
<head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Programaci√≥n
de Servicios y Procesos ‚Äì Unidad 2
‚Äì Programaci√≥n multihilo</title><link href="../../css/styles.css" rel="stylesheet"/></head>
<body lang="es" link="#000080" vlink="#800000"><h1 id="titulo-unidad">Programaci√≥n
de Servicios y Procesos ‚Äì Unidad 2
‚Äì Programaci√≥n multihilo</h1>
<div id="Sumario1">
<div id="Sumario1_Head"><p>
Sumario</p>
</div>
<p><a href="#__RefHeading___Toc1378_1044307265">1. Conceptos b√°sicos de concurrencia y multihilo</a></p>
<p><a href="#__RefHeading___Toc1380_1044307265">1.1. Concurrencia y ejecuci√≥n multihilo</a></p>
<p><a href="#__RefHeading___Toc1382_1044307265">1.2. Thread safety (c√≥digo seguro para hilos)</a></p>
<p><a href="#__RefHeading___Toc1384_1044307265">1.3. Condici√≥n de carrera (Race condition)</a></p>
<p><a href="#__RefHeading___Toc1386_1044307265">1.4. Interferencia entre hilos</a></p>
<p><a href="#__RefHeading___Toc1388_1044307265">1.5. Valor inmutable (Inmutabilidad)</a></p>
<p><a href="#__RefHeading___Toc1390_1044307265">1.6. Operaciones at√≥micas</a></p>
<p><a href="#__RefHeading___Toc1392_1044307265">1.7. Errores de consistencia de memoria</a></p>
<p><a href="#__RefHeading___Toc1394_1044307265">1.8. Visibilidad de memoria y volatile</a></p>
<p><a href="#__RefHeading___Toc1396_1044307265">1.9. M√©todos relevantes de la clase Thread</a></p>
<p><a href="#__RefHeading___Toc1890_1044307265">2. Hilos y creaci√≥n de hilos en Java</a></p>
<p><a href="#__RefHeading___Toc1892_1044307265">2.1. ¬øQu√© es un hilo en Java?</a></p>
<p><a href="#__RefHeading___Toc1894_1044307265">2.2. Formas de crear un hilo en Java</a></p>
<p><a href="#__RefHeading___Toc1896_1044307265">2.3. ¬øCu√°ntas formas hay de implementar un hilo?</a></p>
<p><a href="#__RefHeading___Toc1898_1044307265">2.4. Inicio y ejecuci√≥n de un hilo</a></p>
<p><a href="#__RefHeading___Toc1900_1044307265">2.5. Finalizaci√≥n de un hilo</a></p>
<p><a href="#__RefHeading___Toc1902_1044307265">2.6. Detenci√≥n cooperativa de hilos</a></p>
<p><a href="#__RefHeading___Toc1904_1044307265">2.7. Grupo de hilos (ThreadGroup)</a></p>
<p><a href="#__RefHeading___Toc1906_1044307265">2.8. Relaci√≥n con ExecutorService (visi√≥n completa)</a></p>
<p><a href="#__RefHeading___Toc1908_1044307265">3. Estados y ciclo de vida de los hilos</a></p>
<p><a href="#__RefHeading___Toc1910_1044307265">3.1. Ciclo de vida de un hilo</a></p>
<p><a href="#__RefHeading___Toc1912_1044307265">3.2. Estado NEW</a></p>
<p><a href="#__RefHeading___Toc1914_1044307265">3.3. Estado RUNNABLE</a></p>
<p><a href="#__RefHeading___Toc1916_1044307265">3.4. Estado BLOCKED</a></p>
<p><a href="#__RefHeading___Toc1918_1044307265">3.5. Estado WAITING</a></p>
<p><a href="#__RefHeading___Toc1920_1044307265">3.6. Estado TIMED_WAITING</a></p>
<p><a href="#__RefHeading___Toc1922_1044307265">3.7. Estado TERMINATED</a></p>
<p><a href="#__RefHeading___Toc1924_1044307265">3.8. Transiciones importantes entre estados</a></p>
<p><a href="#__RefHeading___Toc1926_1044307265">3.9. Estados y sincronizaci√≥n</a></p>
<p><a href="#__RefHeading___Toc1928_1044307265">4. Memoria, pila y compartici√≥n de datos entre hilos</a></p>
<p><a href="#__RefHeading___Toc1930_1044307265">4.1. Modelo de memoria en Java (visi√≥n general)</a></p>
<p><a href="#__RefHeading___Toc1932_1044307265">4.2. Variables locales</a></p>
<p><a href="#__RefHeading___Toc1934_1044307265">4.3. Objetos locales (punto conflictivo)</a></p>
<p><a href="#__RefHeading___Toc1936_1044307265">4.4. Miembros de un objeto</a></p>
<p><a href="#__RefHeading___Toc1938_1044307265">4.5. Variables est√°ticas</a></p>
<p><a href="#__RefHeading___Toc1940_1044307265">4.6. ¬øQu√© no se comparte nunca entre hilos?</a></p>
<p><a href="#__RefHeading___Toc1942_1044307265">4.7. Errores comunes de razonamiento</a></p>
<p><a href="#__RefHeading___Toc1944_1044307265">4.8. Relaci√≥n con problemas de concurrencia</a></p>
<p><a href="#__RefHeading___Toc1946_1044307265">5. Sincronizaci√≥n y monitores</a></p>
<p><a href="#__RefHeading___Toc1948_1044307265">5.1. ¬øPara qu√© usamos la sincronizaci√≥n?</a></p>
<p><a href="#__RefHeading___Toc1950_1044307265">5.2. El concepto de monitor</a></p>
<p><a href="#__RefHeading___Toc1952_1044307265">5.3. La palabra clave synchronized</a></p>
<p><a href="#__RefHeading___Toc1954_1044307265">5.4. M√©todos synchronized</a></p>
<p><a href="#__RefHeading___Toc1956_1044307265">5.5. Bloques synchronized</a></p>
<p><a href="#__RefHeading___Toc1958_1044307265">5.6. synchronized y visibilidad de memoria</a></p>
<p><a href="#__RefHeading___Toc1960_1044307265">5.7. volatile vs synchronized</a></p>
<p><a href="#__RefHeading___Toc1962_1044307265">5.8. Problemas derivados de la sincronizaci√≥n</a></p>
<p><a href="#__RefHeading___Toc1964_1044307265">5.9. Thread safety y trampas de examen</a></p>
<p><a href="#__RefHeading___Toc1966_1044307265">6. Planificaci√≥n y prioridad de hilos</a></p>
<p><a href="#__RefHeading___Toc1968_1044307265">6.1. Sistemas de tiempo compartido</a></p>
<p><a href="#__RefHeading___Toc1970_1044307265">6.2. Planificaci√≥n de hilos y la JVM</a></p>
<p><a href="#__RefHeading___Toc1972_1044307265">6.3. Prioridades de los hilos</a></p>
<p><a href="#__RefHeading___Toc1974_1044307265">6.4. Prioridad por defecto</a></p>
<p><a href="#__RefHeading___Toc1976_1044307265">6.5. ¬øQu√© ocurre si todos los hilos tienen m√°xima prioridad?</a></p>
<p><a href="#__RefHeading___Toc1978_1044307265">6.6. Orden de finalizaci√≥n de hilos</a></p>
<p><a href="#__RefHeading___Toc1980_1044307265">6.7. Problemas relacionados con prioridades</a></p>
<p><a href="#__RefHeading___Toc1982_1044307265">6.8. Buenas pr√°cticas</a></p>
<p><a href="#__RefHeading___Toc1984_1044307265">7. Documentaci√≥n y dise√±o de objetos en entornos multihilo</a></p>
<p><a href="#__RefHeading___Toc1986_1044307265">7.1. Operaciones de un objeto</a></p>
<p><a href="#__RefHeading___Toc1988_1044307265">7.2. Operaciones simples y compuestas</a></p>
<p><a href="#__RefHeading___Toc1990_1044307265">7.3. Importancia de la documentaci√≥n en multihilo</a></p>
<p><a href="#__RefHeading___Toc1992_1044307265">7.4. Documentar bloqueos y sincronizaci√≥n</a></p>
<p><a href="#__RefHeading___Toc1994_1044307265">7.5. Sincronizaci√≥n interna vs externa</a></p>
<p><a href="#__RefHeading___Toc1996_1044307265">7.6. Dise√±o de clases seguras para hilos</a></p>
<p><a href="#__RefHeading___Toc1998_1044307265">7.7. Errores habituales en dise√±o</a></p>
<p><a href="#__RefHeading___Toc2000_1044307265">Unidad 02 ‚Äì Programaci√≥n Multihilo (Resumen ultra-compacto)</a></p>
<p><a href="#__RefHeading___Toc2002_1044307265">1. Concurrencia y conceptos b√°sicos</a></p>
<p><a href="#__RefHeading___Toc2004_1044307265">2. Creaci√≥n y ejecuci√≥n de hilos</a></p>
<p><a href="#__RefHeading___Toc2006_1044307265">3. Estados y ciclo de vida</a></p>
<p><a href="#__RefHeading___Toc2008_1044307265">4. Memoria y compartici√≥n</a></p>
<p><a href="#__RefHeading___Toc2010_1044307265">5. Sincronizaci√≥n y monitores</a></p>
<p><a href="#__RefHeading___Toc2012_1044307265">6. Planificaci√≥n y prioridades</a></p>
<p><a href="#__RefHeading___Toc2014_1044307265">7. Documentaci√≥n y dise√±o multihilo</a></p>
<p><a href="#__RefHeading___Toc2016_1044307265">8. M√©todos clave de la clase Thread</a></p>
<p><a href="#__RefHeading___Toc2018_1044307265">Ideas clave de examen</a></p>
</div>
<p>

</p>
<h1 id="__RefHeading___Toc1378_1044307265" lang="es">
<strong>1. Conceptos b√°sicos de concurrencia y multihilo</strong></h1>
<h2 id="__RefHeading___Toc1380_1044307265" lang="es">
<strong>1.1. Concurrencia y ejecuci√≥n multihilo</strong></h2>
<p>La <strong>concurrencia</strong>  consiste en la
ejecuci√≥n simult√°nea (real o aparente) de varias tareas. En Java,
esta concurrencia se implementa principalmente mediante <strong>hilos
(threads)</strong>.</p>
<ul>
<li><p>Un <strong>hilo</strong>  es una unidad de
	ejecuci√≥n dentro de un proceso.</p></li>
<li><p>Un mismo proceso puede contener <strong>varios
	hilos</strong>  que:</p>
<ul>
<li><p>Comparten el <strong>heap</strong>  (memoria de
		objetos)</p></li>
<li><p>Tienen su <strong>propia pila (stack)</strong>  de
		ejecuci√≥n</p></li>
</ul>
</li></ul>
<p>La concurrencia permite:</p>
<ul>
<li><p>Mejor aprovechamiento de la CPU</p></li>
<li><p>Programas m√°s reactivos</p></li>
<li><p>Paralelismo en sistemas multin√∫cleo</p></li>
</ul>
<p>Pero introduce <strong>riesgos</strong>  si no se
controla correctamente.</p>
<hr/>
<h2 id="__RefHeading___Toc1382_1044307265" lang="es">
<strong>1.2. Thread safety (c√≥digo seguro para hilos)</strong></h2>
<p>Un c√≥digo es <strong>thread-safe</strong>  cuando puede
ejecutarse correctamente por varios hilos <strong>al mismo tiempo</strong>,
sin producir:</p>
<ul>
<li><p>Resultados incorrectos</p></li>
<li><p>Estados inconsistentes</p></li>
<li><p>Errores dif√≠ciles de reproducir</p></li>
</ul>
<p>Un c√≥digo thread-safe:</p>
<ul>
<li><p>Protege el acceso a los <strong>recursos
	compartidos</strong></p></li>
<li><p>Garantiza <strong>consistencia de datos</strong></p></li>
<li><p>Garantiza <strong>visibilidad de memoria</strong></p></li>
</ul>
<p>‚ö† Importante:</p>
<ul>
<li><p>Un m√©todo synchronized
<strong>no es sin√≥nimo autom√°tico</strong>  de thread-safe</p></li>
<li><p>Un programa puede ser thread-safe <strong>sin usar
	synchronized</strong>, por ejemplo mediante:</p>
<ul>
<li><p>Inmutabilidad</p></li>
<li><p>Variables locales</p></li>
<li><p>Clases concurrentes</p></li>
</ul>
</li></ul>
<hr/>
<h2 id="__RefHeading___Toc1384_1044307265" lang="es">
<strong>1.3. Condici√≥n de carrera (Race condition)</strong></h2>
<p>Una <strong>condici√≥n de carrera</strong>  ocurre
cuando:</p>
<ul>
<li><p>Varios hilos acceden al mismo recurso</p></li>
<li><p><strong>Al menos uno de ellos escribe</strong></p></li>
<li><p>El resultado depende del <strong>orden de
	ejecuci√≥n</strong></p></li>
</ul>
<p>Ejemplo t√≠pico:</p>
<pre><code>contador++;</code></pre><p>
Esta operaci√≥n <strong>no es at√≥mica</strong>  y puede producir
valores incorrectos si varios hilos la ejecutan simult√°neamente.</p>
<p>Consecuencias:</p>
<ul>
<li><p>Resultados impredecibles</p></li>
<li><p>Errores intermitentes</p></li>
<li><p>Dificultad extrema de depuraci√≥n</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1386_1044307265" lang="es">
<strong>1.4. Interferencia entre hilos</strong></h2>
<p>La <strong>interferencia</strong>  es el efecto concreto
que produce una condici√≥n de carrera:</p>
<ul>
<li><p>Un hilo pisa o invalida el trabajo de otro</p></li>
<li><p>Se pierde informaci√≥n</p></li>
<li><p>El estado final no es coherente</p></li>
</ul>
<p>üëâ La condici√≥n de carrera es el <strong>contexto</strong>,
üëâ
la interferencia es el <strong>problema observable</strong>.</p>
<hr/>
<h2 id="__RefHeading___Toc1388_1044307265" lang="es">
<strong>1.5. Valor inmutable (Inmutabilidad)</strong></h2>
<p>Un <strong>objeto inmutable</strong>  es aquel cuyo
estado:</p>
<ul>
<li><p>Se establece en el constructor</p></li>
<li><p><strong>No puede modificarse despu√©s</strong></p></li>
</ul>
<p>Caracter√≠sticas:</p>
<ul>
<li><p>Campos final</p></li>
<li><p>Sin m√©todos set</p></li>
<li><p>Estado completamente inicializado al crearse</p></li>
</ul>
<p>Ventajas en multihilo:</p>
<ul>
<li><p>Son <strong>intr√≠nsecamente thread-safe</strong></p></li>
<li><p>No necesitan sincronizaci√≥n</p></li>
<li><p>Se pueden compartir libremente entre hilos</p></li>
</ul>
<p>Ejemplos en Java:</p>
<ul>
<li><p>String</p></li>
<li><p>Integer</p></li>
<li><p>LocalDate</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1390_1044307265" lang="es">
<strong>1.6. Operaciones at√≥micas</strong></h2>
<p>Una <strong>operaci√≥n at√≥mica</strong>  es aquella
que:</p>
<ul>
<li><p>Se ejecuta <strong>entera o no se ejecuta</strong></p></li>
<li><p>No puede ser interrumpida por otro hilo</p></li>
</ul>
<p>Ejemplos:</p>
<ul>
<li><p>Lectura/escritura de referencias</p></li>
<li><p>Operaciones de clases Atomic* 
	( AtomicInteger, etc.)</p></li>
</ul>
<p>‚ö† Ojo:</p>
<ul>
<li><p>Que una operaci√≥n est√© escrita en <strong>una
	l√≠nea</strong>  no significa que sea at√≥mica</p></li>
<li><p>contador++
<strong>no es at√≥mica</strong></p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1392_1044307265" lang="es">
<strong>1.7. Errores de consistencia de memoria</strong></h2>
<p>Los <strong>errores de consistencia de memoria</strong> 
ocurren cuando:</p>
<ul>
<li><p>Varios hilos trabajan con los mismos datos</p></li>
<li><p>Cada hilo tiene una <strong>vista distinta</strong> 
	del valor real</p></li>
<li><p>Los cambios de un hilo <strong>no son visibles</strong> 
	para otros</p></li>
</ul>
<p>Esto se debe a:</p>
<ul>
<li><p>Cach√©s de CPU</p></li>
<li><p>Reordenamientos de instrucciones</p></li>
<li><p>Falta de sincronizaci√≥n</p></li>
</ul>
<p>Relacionado con el <strong>Java Memory Model (JMM)</strong>.</p>
<hr/>
<h2 id="__RefHeading___Toc1394_1044307265" lang="es">
<strong>1.8. Visibilidad de memoria y </strong><strong><code>volatile</code></strong></h2>
<p>La palabra clave volatile 
garantiza:</p>
<ul>
<li><p>Que las escrituras de una variable sean visibles
	para otros hilos</p></li>
<li><p>Que no se reordenen ciertas operaciones</p></li>
</ul>
<p>volatile:</p>
<ul>
<li><p><strong>No garantiza exclusi√≥n mutua</strong></p></li>
<li><p><strong>No evita condiciones de carrera</strong></p></li>
<li><p>Solo asegura <strong>visibilidad</strong></p></li>
</ul>
<p>Se usa para:</p>
<ul>
<li><p>Flags de control</p></li>
<li><p>Estados simples compartidos</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1396_1044307265" lang="es">
<strong>1.9. M√©todos relevantes de la clase </strong><strong><code>Thread</code></strong></h2>
<p>La clase Thread  define
m√©todos fundamentales para trabajar con hilos.
Incluye <strong>m√©todos
de instancia y est√°ticos</strong>.</p>
<h3 lang="es">M√©todos clave:</h3>
<ul>
<li><p>run()  ‚Üí c√≥digo que
	ejecuta el hilo</p></li>
<li><p>start()  ‚Üí inicia el
	hilo (no ejecuta run()  directamente)</p></li>
<li><p>getId()  ‚Üí
	identificador del hilo</p></li>
<li><p>getName()  / setName()</p></li>
<li><p>getPriority()  /
	setPriority()</p></li>
<li><p>currentThread() 
	(est√°tico) ‚Üí devuelve el hilo actual</p></li>
<li><p>sleep()  (est√°tico)</p></li>
<li><p>join()</p></li>
</ul>
<p>üìå Punto importante (examen):</p>
<blockquote>Aunque algunos
sean est√°ticos y otros de instancia, <strong>todos pertenecen a la
clase Thread</strong>.</blockquote>
<hr/>
<h1 id="__RefHeading___Toc1890_1044307265" lang="es">
<strong>2. Hilos y creaci√≥n de hilos en Java</strong></h1>
<p>Este tema desarrolla <strong>c√≥mo se crean, ejecutan y
finalizan los hilos</strong>, ampliando lo que apareci√≥ en las
preguntas y cubriendo <strong>todo el enfoque real de Java</strong>,
no solo el de examen.</p>
<hr/>
<h2 id="__RefHeading___Toc1892_1044307265" lang="es">
<strong>2.1. ¬øQu√© es un hilo en Java?</strong></h2>
<p>En Java, un <strong>hilo</strong>  es una instancia de
ejecuci√≥n representada por la clase:</p>
<pre><code>java.lang.Thread</code></pre><p>
Cada hilo:</p>
<ul>
<li><p>Tiene su propio <strong>flujo de ejecuci√≥n</strong></p></li>
<li><p>Comparte el <strong>heap</strong>  con otros hilos
	del mismo proceso</p></li>
<li><p>Ejecuta c√≥digo concurrentemente con otros hilos</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1894_1044307265" lang="es">
<strong>2.2. Formas de crear un hilo en Java</strong></h2>
<h3 lang="es"><strong>2.2.1. Heredando de la clase
</strong><strong><code>Thread</code></strong></h3>
<pre><code>class MiHilo extends Thread {</code>
<code>    </code><code>@Override</code>
<code>    </code><code>public void run() {</code>
<code>        </code><code>// c√≥digo del hilo</code>
<code>    </code><code>}</code>
<code>}</code></pre><p>
Ejecuci√≥n:</p>
<pre><code>MiHilo h = new MiHilo();</code>
<code>h.start();</code></pre><p>
Caracter√≠sticas:</p>
<ul>
<li><p>Se sobrescribe <strong>run()</strong></p></li>
<li><p>start()  crea un nuevo
	hilo y luego llama internamente a run()</p></li>
<li><p>No permite heredar de otra clase (limitaci√≥n
	importante)</p></li>
</ul>
<p>üìå Pregunta t√≠pica de examen:</p>
<blockquote>¬øQu√© m√©todo
se sobrescribe al heredar de Thread? ‚Üí <strong>run()</strong></blockquote>
<hr/>
<h3 lang="es"><strong>2.2.2. Implementando la
interfaz </strong><strong><code>Runnable</code></strong></h3>
<pre><code>class MiTarea implements Runnable {</code>
<code>    </code><code>@Override</code>
<code>    </code><code>public void run() {</code>
<code>        </code><code>// c√≥digo concurrente</code>
<code>    </code><code>}</code>
<code>}</code>
<code>Thread h = new Thread(new MiTarea());</code>
<code>h.start();</code></pre><p>
Ventajas:</p>
<ul>
<li><p>Permite heredar de otra clase</p></li>
<li><p>Separaci√≥n entre <strong>tarea</strong>  y <strong>hilo</strong></p></li>
<li><p>M√°s flexible y reutilizable</p></li>
</ul>
<p>üìå Es la <strong>forma recomendada</strong>  en la
mayor√≠a de los casos.</p>
<hr/>
<h3 lang="es"><strong>2.2.3. Implementando
</strong><strong><code>Callable&lt;V&gt;</code></strong></h3>
<p>Callable  es similar a
Runnable, pero:</p>
<ul>
<li><p>Devuelve un valor</p></li>
<li><p>Puede lanzar <strong>excepciones comprobadas</strong></p></li>
</ul>
<pre><code>Callable&lt;Integer&gt; tarea = () -&gt; 42;</code></pre><p>
Se ejecuta mediante un <strong>ExecutorService</strong>  y devuelve un
Future&lt;V&gt;.</p>
<p>Se usa cuando:</p>
<ul>
<li><p>Necesitamos obtener un resultado</p></li>
<li><p>Queremos gestionar excepciones</p></li>
</ul>
<p>üìå Pregunta de examen:</p>
<blockquote>¬øCu√°ndo es
preferible usar Callable a Runnable?<br/>
‚Üí Cuando necesitamos
<strong>retornar un valor y/o lanzar excepciones comprobadas</strong>.</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1896_1044307265" lang="es">
<strong>2.3. ¬øCu√°ntas formas hay de implementar un hilo?</strong></h2>
<p>Desde el punto de vista acad√©mico del temario:</p>
<ul>
<li><p><strong>Dos</strong>: Thread 
	y Runnable</p></li>
<li><p>Ampliado: Callable 
	(con ejecutores)</p></li>
</ul>
<p>üìå En ex√°menes suele aceptarse:</p>
<blockquote><b>Dos</b>,
aunque tambi√©n es t√©cnicamente correcto tres.</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1898_1044307265" lang="es">
<strong>2.4. Inicio y ejecuci√≥n de un hilo</strong></h2>
<ul>
<li><p>start():</p>
<ul>
<li><p>Crea un nuevo hilo</p></li>
<li><p>Cambia el estado a <strong>Runnable</strong></p></li>
<li><p>Llama internamente a run()</p></li>
</ul>
</li></ul>
<p>‚ö† Error com√∫n:</p>
<pre><code>h.run(); // NO crea un hilo nuevo</code></pre><p>
Esto ejecuta el c√≥digo <strong>en el hilo actual</strong>.</p>
<hr/>
<h2 id="__RefHeading___Toc1900_1044307265" lang="es">
<strong>2.5. Finalizaci√≥n de un hilo</strong></h2>
<p>Un hilo <strong>finaliza</strong>  cuando:</p>
<ul>
<li><p>Termina la ejecuci√≥n de su m√©todo run() 
	o call()</p></li>
</ul>
<p>No existe:</p>
<ul>
<li><p>stopThread()</p></li>
<li><p>killThread()</p></li>
<li><p>endThread()</p></li>
</ul>
<p>üìå Pregunta de examen:</p>
<blockquote>¬øQu√© m√©todo
produce la finalizaci√≥n de un hilo?<br/>
‚Üí <strong>Ninguno</strong>.
El hilo termina cuando acaba su m√©todo principal.</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1902_1044307265" lang="es">
<strong>2.6. Detenci√≥n cooperativa de hilos</strong></h2>
<p>La forma correcta de detener un hilo es:</p>
<ul>
<li><p>Usar una <strong>variable de control</strong></p></li>
<li><p>Comprobarla peri√≥dicamente</p></li>
</ul>
<p>Ejemplo:</p>
<pre><code>volatile boolean detener = false;</code></pre><p>
Nunca se debe usar:</p>
<ul>
<li><p>Thread.stop() 
	(obsoleto y peligroso)</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1904_1044307265" lang="es">
<strong>2.7. Grupo de hilos (</strong><strong><code>ThreadGroup</code></strong><strong>)</strong></h2>
<p>Un ThreadGroup  permite:</p>
<ul>
<li><p>Agrupar hilos</p></li>
<li><p>Aplicar operaciones comunes</p></li>
<li><p>Gestionar jerarqu√≠as de grupos</p></li>
</ul>
<p>üìå Respuesta correcta de examen:</p>
<blockquote>Permite
<strong>gestionar grupos de hebras</strong>.</blockquote>
<p>Hoy en d√≠a:</p>
<ul>
<li><p>Est√° <strong>en desuso</strong></p></li>
<li><p>Sustituido por ExecutorService</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1906_1044307265" lang="es">
<strong>2.8. Relaci√≥n con </strong><strong><code>ExecutorService</code></strong><strong>
(visi√≥n completa)</strong></h2>
<p>Aunque no siempre entra en examen:</p>
<ul>
<li><p>Java moderno <strong>no gestiona hilos manualmente</strong></p></li>
<li><p>Usa <strong>ejecutores</strong>:</p>
<ul>
<li><p>Pool de hilos</p></li>
<li><p>Gesti√≥n autom√°tica</p></li>
<li><p>Mejor escalabilidad</p></li>
</ul>
</li></ul>
<p>Ejemplo:</p>
<pre><code>ExecutorService executor = Executors.newFixedThreadPool(4);</code></pre>
<hr/>
<h1 id="__RefHeading___Toc1908_1044307265" lang="es">
<strong>3. Estados y ciclo de vida de los hilos</strong></h1>
<p>Este tema describe <strong>c√≥mo evoluciona un hilo
desde que se crea hasta que finaliza</strong>, qu√© estados existen y
c√≥mo se producen las transiciones entre ellos. Es un tema <strong>muy
preguntado en examen</strong>.</p>
<hr/>
<h2 id="__RefHeading___Toc1910_1044307265" lang="es">
<strong>3.1. Ciclo de vida de un hilo</strong></h2>
<p>En Java, el ciclo de vida oficial de un hilo est√°
definido por la enumeraci√≥n:</p>
<pre><code>Thread.State</code></pre><p>
Los estados son:</p>
<ol>
<li><p><strong>NEW</strong></p></li>
<li><p><strong>RUNNABLE</strong></p></li>
<li><p><strong>BLOCKED</strong></p></li>
<li><p><strong>WAITING</strong></p></li>
<li><p><strong>TIMED_WAITING</strong></p></li>
<li><p><strong>TERMINATED</strong></p></li>
</ol>
<p>üìå Respuesta t√≠pica de examen:</p>
<blockquote>New, Runnable,
Waiting, Timed Waiting, Terminated</blockquote>
<p>(Algunas respuestas simplifican u omiten BLOCKED ).</p>
<hr/>
<h2 id="__RefHeading___Toc1912_1044307265" lang="es">
<strong>3.2. Estado NEW</strong></h2>
<ul>
<li><p>El hilo ha sido creado</p></li>
<li><p>A√∫n <strong>no se ha llamado a </strong><strong>start()</strong></p></li>
</ul>
<pre><code>Thread h = new Thread();</code></pre><p>
No consume CPU.</p>
<hr/>
<h2 id="__RefHeading___Toc1914_1044307265" lang="es">
<strong>3.3. Estado RUNNABLE</strong></h2>
<ul>
<li><p>El hilo est√°:</p>
<ul>
<li><p>Ejecut√°ndose <strong>o</strong></p></li>
<li><p>Listo para ejecutarse</p></li>
</ul>
</li></ul>
<p>üìå Importante:</p>
<blockquote>Java <strong>no
distingue</strong> entre ‚Äúlisto‚Äù y ‚Äúejecutando‚Äù</blockquote>
<p>El <strong>sistema operativo</strong>  decide cu√°ndo
ejecutarlo realmente.</p>
<hr/>
<h2 id="__RefHeading___Toc1916_1044307265" lang="es">
<strong>3.4. Estado BLOCKED</strong></h2>
<p>Un hilo entra en <strong>BLOCKED</strong>  cuando:</p>
<ul>
<li><p>Intenta acceder a un recurso protegido
	( synchronized )</p></li>
<li><p>Otro hilo posee el monitor</p></li>
</ul>
<p>Ejemplo:</p>
<pre><code>synchronized(obj) {</code>
<code>   </code><code>// otro hilo ya est√° dentro</code>
<code>}</code></pre>
<hr/>
<h2 id="__RefHeading___Toc1918_1044307265" lang="es">
<strong>3.5. Estado WAITING</strong></h2>
<p>El hilo espera indefinidamente hasta que:</p>
<ul>
<li><p>Otro hilo lo despierte</p></li>
</ul>
<p>Se produce con:</p>
<ul>
<li><p>wait()</p></li>
<li><p>join()</p></li>
<li><p>LockSupport.park()</p></li>
</ul>
<p>No consume CPU.</p>
<hr/>
<h2 id="__RefHeading___Toc1920_1044307265" lang="es">
<strong>3.6. Estado TIMED_WAITING</strong></h2>
<p>Similar a WAITING, pero
con <strong>tiempo m√°ximo</strong>.</p>
<p>Se produce con:</p>
<ul>
<li><p>sleep(long)</p></li>
<li><p>wait(long)</p></li>
<li><p>join(long)</p></li>
</ul>
<p>Cuando el tiempo termina, el hilo vuelve a <strong>RUNNABLE</strong>.</p>
<hr/>
<h2 id="__RefHeading___Toc1922_1044307265" lang="es">
<strong>3.7. Estado TERMINATED</strong></h2>
<ul>
<li><p>El hilo ha terminado su ejecuci√≥n</p></li>
<li><p>No puede reiniciarse</p></li>
</ul>
<p>Un hilo llega aqu√≠ cuando:</p>
<ul>
<li><p>run()  o call() 
	finaliza</p></li>
<li><p>Se lanza una excepci√≥n no controlada</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1924_1044307265" lang="es">
<strong>3.8. Transiciones importantes entre estados</strong></h2>
<ul>
<li><p>NEW ‚Üí RUNNABLE  ‚Üí
	start()</p></li>
<li><p>RUNNABLE ‚Üí BLOCKED 
	‚Üí espera monitor</p></li>
<li><p>RUNNABLE ‚Üí WAITING 
	‚Üí wait(), join()</p></li>
<li><p>WAITING / TIMED_WAITING ‚Üí
	RUNNABLE  ‚Üí notificaci√≥n / tiempo</p></li>
<li><p>RUNNABLE ‚Üí TERMINATED 
	‚Üí fin de ejecuci√≥n</p></li>
</ul>
<p>üìå Pregunta t√≠pica:</p>
<blockquote>Cuando se
desbloquea un hilo, ¬øa qu√© estado pasa?<br/>
‚Üí <strong>RUNNABLE
(Listo)</strong></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1926_1044307265" lang="es">
<strong>3.9. Estados y sincronizaci√≥n</strong></h2>
<ul>
<li><p>Los estados est√°n directamente relacionados con:</p>
<ul>
<li><p>Monitores</p></li>
<li><p>Bloqueos</p></li>
<li><p>Planificaci√≥n</p></li>
</ul>
</li></ul>
<p>Un mal dise√±o puede producir:</p>
<ul>
<li><p>Hilos bloqueados indefinidamente</p></li>
<li><p>Deadlocks</p></li>
<li><p>Starvation</p></li>
</ul>
<hr/>
<h1 id="__RefHeading___Toc1928_1044307265" lang="es">
<strong>4. Memoria, pila y compartici√≥n de datos entre hilos</strong></h1>
<p>Este tema es <strong>clave para entender por qu√©
aparecen los problemas de concurrencia</strong>. Muchas preguntas de
examen salen directamente de aqu√≠.</p>
<hr/>
<h2 id="__RefHeading___Toc1930_1044307265" lang="es">
<strong>4.1. Modelo de memoria en Java (visi√≥n general)</strong></h2>
<p>En un programa Java con varios hilos existen, a grandes
rasgos, dos zonas de memoria:</p>
<h3 lang="es"><strong>Memoria compartida (Heap)</strong></h3>
<ul>
<li><p>Objetos</p></li>
<li><p>Miembros de objetos</p></li>
<li><p>Variables est√°ticas</p></li>
</ul>
<h3 lang="es"><strong>Memoria privada por hilo
(Stack)</strong></h3>
<ul>
<li><p>Variables locales</p></li>
<li><p>Par√°metros de m√©todos</p></li>
<li><p>Pila de llamadas</p></li>
</ul>
<p>üìå Regla fundamental:</p>
<blockquote><strong>Todo lo
que est√° en el heap puede ser compartido</strong><br/>
<strong>Todo
lo que est√° en el stack es privado del hilo</strong></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1932_1044307265" lang="es">
<strong>4.2. Variables locales</strong></h2>
<p>Las <strong>variables locales</strong>:</p>
<ul>
<li><p>Se almacenan en la <strong>pila (stack)</strong> 
	del hilo</p></li>
<li><p>Son <strong>exclusivas</strong>  de cada hilo</p></li>
<li><p><strong>Nunca se comparten</strong>  entre hilos</p></li>
</ul>
<p>üìå Respuesta de examen:</p>
<blockquote>Las variables
locales <strong>nunca son compartidas por hilos</strong></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1934_1044307265" lang="es">
<strong>4.3. Objetos locales (punto conflictivo)</strong></h2>
<p>Un <strong>objeto local</strong>:</p>
<pre><code>void metodo() {</code>
<code>    </code><code>Objeto o = new Objeto();</code>
<code>}</code></pre>
<ul>
<li><p>La <strong>referencia</strong>  es local (stack)</p></li>
<li><p>El <strong>objeto</strong>  se almacena en el <strong>heap</strong></p></li>
</ul>
<p>üëâ Por tanto:</p>
<ul>
<li><p>El objeto <strong>s√≠ puede ser compartido</strong> 
	si su referencia se escapa</p></li>
<li><p><strong>No es intr√≠nsecamente seguro</strong></p></li>
</ul>
<p>üìå Pregunta t√≠pica:</p>
<blockquote>¬øPor qu√© el
uso de objetos locales no es seguro?<br/>
‚Üí Porque <strong>se
almacenan en el heap compartido</strong></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1936_1044307265" lang="es">
<strong>4.4. Miembros de un objeto</strong></h2>
<p>Los <strong>miembros (atributos)</strong>:</p>
<ul>
<li><p>Se almacenan en el <strong>heap</strong></p></li>
<li><p>Son compartidos si varios hilos acceden a la <strong>misma
	instancia</strong></p></li>
</ul>
<p>üìå Respuesta t√≠pica:</p>
<blockquote>Usar miembros de
objetos en multihilo es peligroso<br/>
‚Üí <strong>Si dos hilos
acceden a la misma instancia</strong></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1938_1044307265" lang="es">
<strong>4.5. Variables est√°ticas</strong></h2>
<p>Las variables static:</p>
<ul>
<li><p>Pertenecen a la clase</p></li>
<li><p>Hay <strong>una sola copia</strong></p></li>
<li><p>Son <strong>compartidas por todos los hilos</strong></p></li>
</ul>
<p>Requieren:</p>
<ul>
<li><p>Sincronizaci√≥n</p></li>
<li><p>Atomicidad</p></li>
<li><p>O inmutabilidad</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1940_1044307265" lang="es">
<strong>4.6. ¬øQu√© no se comparte nunca entre hilos?</strong></h2>
<p>‚úî Variables locales 
‚úî Pila de ejecuci√≥n 
‚úî
Par√°metros de m√©todos</p>
<p>üìå Respuesta de examen:</p>
<blockquote>Todo lo
almacenado en la <strong>pila de cada hilo</strong></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1942_1044307265" lang="es">
<strong>4.7. Errores comunes de razonamiento</strong></h2>
<p>‚ùå ‚ÄúEs local, luego es seguro‚Äù ‚Üí FALSO
(objetos) 
‚ùå ‚ÄúEst√° en un m√©todo, luego no se comparte‚Äù ‚Üí
FALSO 
‚úî ‚ÄúEst√° en el stack‚Äù ‚Üí seguro 
‚úî
‚ÄúEst√° en el heap‚Äù ‚Üí potencialmente compartido</p>
<hr/>
<h2 id="__RefHeading___Toc1944_1044307265" lang="es">
<strong>4.8. Relaci√≥n con problemas de concurrencia</strong></h2>
<p>Los problemas aparecen cuando:</p>
<ul>
<li><p>Hay <strong>estado compartido</strong></p></li>
<li><p>Hay <strong>escrituras concurrentes</strong></p></li>
<li><p>No hay sincronizaci√≥n</p></li>
</ul>
<p>Esto conduce a:</p>
<ul>
<li><p>Condiciones de carrera</p></li>
<li><p>Interferencias</p></li>
<li><p>Inconsistencia de memoria</p></li>
</ul>
<hr/>
<h1 id="__RefHeading___Toc1946_1044307265" lang="es">
<strong>5. Sincronizaci√≥n y monitores</strong></h1>
<p>Este es el <strong>n√∫cleo t√©cnico</strong>  de la
programaci√≥n multihilo en Java. Aqu√≠ se explican los mecanismos que
permiten <strong>controlar el acceso concurrente</strong>  a recursos
compartidos y evitar los problemas vistos en los temas anteriores.</p>
<hr/>
<h2 id="__RefHeading___Toc1948_1044307265" lang="es">
<strong>5.1. ¬øPara qu√© usamos la sincronizaci√≥n?</strong></h2>
<p>La <strong>sincronizaci√≥n entre hilos</strong>  se
utiliza para:</p>
<ul>
<li><p>Evitar <strong>condiciones de carrera</strong></p></li>
<li><p>Prevenir <strong>interferencias entre hilos</strong></p></li>
<li><p>Garantizar <strong>consistencia de memoria</strong></p></li>
<li><p>Asegurar <strong>exclusi√≥n mutua</strong></p></li>
<li><p>Garantizar <strong>visibilidad de cambios</strong></p></li>
</ul>
<p>üìå Idea clave:</p>
<blockquote>Sincronizar no
es ‚Äúhacer m√°s lento‚Äù el programa,<br/>
es <strong>hacerlo
correcto</strong>.</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1950_1044307265" lang="es">
<strong>5.2. El concepto de monitor</strong></h2>
<p>La sincronizaci√≥n en Java se construye alrededor de
una entidad interna llamada:</p>
<p>üëâ <strong>monitor</strong></p>
<p>Un <strong>monitor</strong>:</p>
<ul>
<li><p>Est√° asociado a <strong>cada objeto</strong></p></li>
<li><p>Permite que <strong>solo un hilo</strong>  ejecute
	c√≥digo sincronizado a la vez</p></li>
<li><p>Es gestionado autom√°ticamente por la JVM</p></li>
</ul>
<p>üìå Pregunta de examen:</p>
<blockquote>Podemos
construir la sincronizaci√≥n alrededor de una entidad interna
conocida como‚Ä¶<br/>
‚Üí <strong>monitor</strong></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1952_1044307265" lang="es">
<strong>5.3. La palabra clave </strong><strong><code>synchronized</code></strong></h2>
<p>synchronized  permite
definir <strong>secciones cr√≠ticas</strong>, es decir, zonas de
c√≥digo que:</p>
<ul>
<li><p>No pueden ejecutarse simult√°neamente por varios
	hilos</p></li>
<li><p>Protegen recursos compartidos</p></li>
</ul>
<p>Puede aplicarse a:</p>
<ul>
<li><p>M√©todos</p></li>
<li><p>Bloques de c√≥digo</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1954_1044307265" lang="es">
<strong>5.4. M√©todos </strong><strong><code>synchronized</code></strong></h2>
<pre><code>public synchronized void metodo() {</code>
<code>    </code><code>// secci√≥n cr√≠tica</code>
<code>}</code></pre><p>
Caracter√≠sticas:</p>
<ul>
<li><p>El hilo adquiere el <strong>monitor del objeto</strong></p></li>
<li><p>Ning√∫n otro hilo puede entrar en m√©todos
	sincronizados del mismo objeto</p></li>
<li><p>Al salir, el monitor se libera</p></li>
</ul>
<p>üìå Pregunta t√≠pica:</p>
<blockquote>¬øQu√©
conseguimos con los m√©todos synchronized?<br/>
‚Üí Que <strong>dos
m√©todos no accedan simult√°neamente a un recurso</strong></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1956_1044307265" lang="es">
<strong>5.5. Bloques </strong><strong><code>synchronized</code></strong></h2>
<pre><code>synchronized(objeto) {</code>
<code>    </code><code>// secci√≥n cr√≠tica</code>
<code>}</code></pre><p>
Ventajas:</p>
<ul>
<li><p>Mayor control</p></li>
<li><p>Mejor rendimiento</p></li>
<li><p>Sincronizaci√≥n m√°s fina</p></li>
</ul>
<p>Se sincroniza expl√≠citamente sobre:</p>
<ul>
<li><p>Un objeto</p></li>
<li><p>Un monitor concreto</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1958_1044307265" lang="es">
<strong>5.6. </strong><strong><code>synchronized</code></strong><strong>
y visibilidad de memoria</strong></h2>
<p>Adem√°s de exclusi√≥n mutua, synchronized 
garantiza que:</p>
<ul>
<li><p>Los cambios realizados por un hilo</p></li>
<li><p>Sean visibles para los dem√°s hilos</p></li>
</ul>
<p>Por eso:</p>
<ul>
<li><p>Soluciona <strong>interferencias</strong></p></li>
<li><p>Soluciona <strong>errores de consistencia de
	memoria</strong></p></li>
</ul>
<p>üìå Pregunta de examen:</p>
<blockquote>Un m√©todo
declarado synchronized‚Ä¶<br/>
‚Üí Soluciona interferencias y
problemas de consistencia de memoria</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1960_1044307265" lang="es">
<strong>5.7. </strong><strong><code>volatile</code></strong><strong>
vs </strong><strong><code>synchronized</code></strong></h2>
<table>
<thead>
<tr>
<th>volatile
</th>
<th>synchronized
</th>
</tr>
</thead>
<tbody>
<tr>
<td>Garantiza
				visibilidad
</td>
<td>Garantiza
				visibilidad
</td>
</tr>
<tr>
<td>No garantiza
				exclusi√≥n
</td>
<td>Garantiza
				exclusi√≥n
</td>
</tr>
<tr>
<td>No evita race
				conditions
</td>
<td>Evita race
				conditions
</td>
</tr>
<tr>
<td>M√°s ligero
</td>
<td>M√°s costoso
</td>
</tr>
</tbody>
</table>
<p>üìå Importante:</p>
<blockquote><code>volatile</code>
<strong>no sustituye</strong> a <code>synchronized</code></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1962_1044307265" lang="es">
<strong>5.8. Problemas derivados de la sincronizaci√≥n</strong></h2>
<h3 lang="es"><strong>Interbloqueo (Deadlock)</strong></h3>
<p>Ocurre cuando:</p>
<ul>
<li><p>Dos o m√°s hilos</p></li>
<li><p>Esperan indefinidamente recursos bloqueados entre
	s√≠</p></li>
</ul>
<p>üìå Pregunta de examen:</p>
<blockquote>Los m√©todos
synchronized‚Ä¶<br/>
‚Üí <strong>Pueden ocasionar interbloqueos</strong></blockquote>
<hr/>
<h3 lang="es"><strong>Starvation</strong></h3>
<p>Un hilo:</p>
<ul>
<li><p>Nunca consigue CPU o recursos</p></li>
<li><p>Debido a prioridades o bloqueos excesivos</p></li>
</ul>
<hr/>
<h3 lang="es"><strong>Livelock</strong></h3>
<p>Los hilos:</p>
<ul>
<li><p>No est√°n bloqueados</p></li>
<li><p>Pero no progresan</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1964_1044307265" lang="es">
<strong>5.9. Thread safety y trampas de examen</strong></h2>
<p>üìå Punto conflictivo que detectaste correctamente:</p>
<p>Pregunta:</p>
<blockquote>Para hacer un
hilo seguro los m√©todos deben declararse como‚Ä¶</blockquote>
<p>Respuesta t√©cnica real:</p>
<ul>
<li><p>synchronized  (una de
	las formas)</p></li>
</ul>
<p>Respuesta correcta de examen:</p>
<ul>
<li><p><strong>Ninguna respuesta es correcta</strong></p></li>
</ul>
<p>üëâ Motivo:</p>
<ul>
<li><p>No hay <strong>una √∫nica forma</strong></p></li>
<li><p>La respuesta ofrecida es <strong>incompleta</strong></p></li>
</ul>
<p>‚ö† Regla pr√°ctica de examen:</p>
<blockquote>Si todas las
opciones son parciales ‚Üí <strong>‚ÄúNinguna es correcta‚Äù</strong></blockquote>
<hr/>
<h1 id="__RefHeading___Toc1966_1044307265" lang="es">
<strong>6. Planificaci√≥n y prioridad de hilos</strong></h1>
<p>Este tema explica <strong>c√≥mo se decide qu√© hilo se
ejecuta en cada momento</strong>, qu√© papel juegan las prioridades y
cu√°les son las <strong>limitaciones reales de Java</strong>  frente
al sistema operativo.</p>
<hr/>
<h2 id="__RefHeading___Toc1968_1044307265" lang="es">
<strong>6.1. Sistemas de tiempo compartido</strong></h2>
<p>En un <strong>sistema de tiempo compartido</strong>:</p>
<ul>
<li><p>La CPU se divide en <strong>fracciones de tiempo</strong> 
	(time slices)</p></li>
<li><p>Varios hilos parecen ejecutarse simult√°neamente</p></li>
<li><p>El cambio entre hilos se llama <strong>cambio de
	contexto</strong></p></li>
</ul>
<p>üìå Pregunta de examen:</p>
<blockquote>En un sistema de
tiempo compartido‚Ä¶<br/>
‚Üí El uso de la CPU se divide en
fracciones de tiempo</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1970_1044307265" lang="es">
<strong>6.2. Planificaci√≥n de hilos y la JVM</strong></h2>
<h3 lang="es">¬øQui√©n decide qu√© hilo se ejecuta?</h3>
<p>En Java:</p>
<ul>
<li><p>La <strong>JVM no implementa un algoritmo propio
	de planificaci√≥n</strong></p></li>
<li><p>Delega la planificaci√≥n en el <strong>sistema
	operativo</strong></p></li>
</ul>
<p>üìå Respuesta esperada en examen:</p>
<blockquote>La JVM <strong>no
posee un algoritmo de planificaci√≥n</strong> para la ejecuci√≥n de
hilos</blockquote>
<p>‚ö† Matiz t√©cnico real:</p>
<ul>
<li><p>La JVM mapea hilos Java a hilos del SO</p></li>
<li><p>Pero para el temario ‚Üí <strong>no planifica</strong></p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1972_1044307265" lang="es">
<strong>6.3. Prioridades de los hilos</strong></h2>
<p>Cada hilo tiene una <strong>prioridad</strong>, que
influye (pero no garantiza) su ejecuci√≥n.</p>
<h3 lang="es">Rango de prioridades en Java</h3>
<ul>
<li><p>Valores enteros de <strong>1 a 10</strong></p></li>
<li><p>Constantes:</p>
<ul>
<li><p>MIN_PRIORITY  = 1</p></li>
<li><p>NORM_PRIORITY  = 5</p></li>
<li><p>MAX_PRIORITY  = 10</p></li>
</ul>
</li></ul>
<p>üìå Punto conflictivo detectado:</p>
<blockquote>No existe
<code>DEFAULT_PRIORITY</code></blockquote>
<hr/>
<h2 id="__RefHeading___Toc1974_1044307265" lang="es">
<strong>6.4. Prioridad por defecto</strong></h2>
<p>Cuando se crea un hilo:</p>
<ul>
<li><p>Hereda la prioridad del hilo que lo crea</p></li>
<li><p>Normalmente es <strong>NORM_PRIORITY (5)</strong></p></li>
</ul>
<p>üìå Preguntas de examen:</p>
<ul>
<li><p>¬øQu√© prioridad por defecto tiene un hilo? ‚Üí
	NORM_PRIORITY</p></li>
<li><p>Valor num√©rico ‚Üí <strong>5</strong></p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1976_1044307265" lang="es">
<strong>6.5. ¬øQu√© ocurre si todos los hilos tienen m√°xima
prioridad?</strong></h2>
<ul>
<li><p>La prioridad es <strong>relativa</strong></p></li>
<li><p>Si todos tienen la misma prioridad:</p>
<ul>
<li><p>No se obtiene ninguna ventaja</p></li>
<li><p>El SO decide el orden</p></li>
</ul>
</li></ul>
<p>üìå Respuesta correcta:</p>
<blockquote>No conseguimos
nada, puesto que la prioridad es algo relativo</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1978_1044307265" lang="es">
<strong>6.6. Orden de finalizaci√≥n de hilos</strong></h2>
<p>Si lanzamos varios hilos:</p>
<ul>
<li><p>Con la misma prioridad</p></li>
<li><p>Sin sincronizaci√≥n expl√≠cita</p></li>
</ul>
<p>üëâ <strong>No podemos saber el orden de finalizaci√≥n</strong></p>
<p>Depende de:</p>
<ul>
<li><p>Planificador del SO</p></li>
<li><p>Carga del sistema</p></li>
<li><p>Tiempo de ejecuci√≥n</p></li>
</ul>
<p>üìå Respuesta de examen:</p>
<blockquote>No estamos
seguros, depende del sistema operativo</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1980_1044307265" lang="es">
<strong>6.7. Problemas relacionados con prioridades</strong></h2>
<h3 lang="es"><strong>Starvation (inanici√≥n)</strong></h3>
<ul>
<li><p>Hilos de baja prioridad</p></li>
<li><p>Nunca reciben CPU suficiente</p></li>
</ul>
<h3 lang="es"><strong>Inversi√≥n de prioridades</strong></h3>
<ul>
<li><p>Un hilo de baja prioridad bloquea a uno de alta</p></li>
<li><p>Problema cl√°sico en sistemas concurrentes</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1982_1044307265" lang="es">
<strong>6.8. Buenas pr√°cticas</strong></h2>
<ul>
<li><p>No confiar en prioridades para l√≥gica del
	programa</p></li>
<li><p>Usar sincronizaci√≥n y dise√±o correcto</p></li>
<li><p>Preferir ejecutores ( ExecutorService )</p></li>
</ul>
<hr/>
<h1 id="__RefHeading___Toc1984_1044307265" lang="es">
<strong>7. Documentaci√≥n y dise√±o de objetos en entornos multihilo</strong></h1>
<p>Este tema suele parecer ‚Äúte√≥rico‚Äù, pero es <strong>cr√≠tico
en sistemas concurrentes reales</strong>  y tambi√©n aparece en examen
de forma muy concreta.</p>
<hr/>
<h2 id="__RefHeading___Toc1986_1044307265" lang="es">
<strong>7.1. Operaciones de un objeto</strong></h2>
<p>Las <strong>operaciones de un objeto</strong>  provienen
de:</p>
<ul>
<li><p><strong>Los m√©todos del propio objeto</strong></p></li>
</ul>
<p>üìå Respuesta de examen:</p>
<blockquote>¬øDe d√≥nde
pueden venir las operaciones de un objeto?<br/>
‚Üí De m√©todos del
propio objeto</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1988_1044307265" lang="es">
<strong>7.2. Operaciones simples y compuestas</strong></h2>
<p>Un objeto puede ofrecer:</p>
<ul>
<li><p><strong>Operaciones de una sola llamada</strong></p></li>
<li><p><strong>Operaciones compuestas</strong>  (varias
	llamadas que deben tratarse como una unidad)</p></li>
</ul>
<p>Las operaciones compuestas:</p>
<ul>
<li><p>Son especialmente peligrosas en multihilo</p></li>
<li><p>Requieren sincronizaci√≥n externa o interna</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1990_1044307265" lang="es">
<strong>7.3. Importancia de la documentaci√≥n en multihilo</strong></h2>
<p>En entornos concurrentes, la documentaci√≥n debe
indicar claramente:</p>
<ul>
<li><p>Qu√© m√©todos son:</p>
<ul>
<li><p>Thread-safe</p></li>
<li><p>No thread-safe</p></li>
</ul>
<li><p>Qu√© operaciones:</p>
<ul>
<li><p>Bloquean</p></li>
<li><p>Pueden esperar indefinidamente</p></li>
</ul>
</li></li></ul>
<p>üìå Pregunta de examen:</p>
<blockquote>La documentaci√≥n
en procesos multihilo‚Ä¶<br/>
‚Üí Debe indicar cu√°ndo se necesita un
bloqueo antes de realizar una operaci√≥n</blockquote>
<hr/>
<h2 id="__RefHeading___Toc1992_1044307265" lang="es">
<strong>7.4. Documentar bloqueos y sincronizaci√≥n</strong></h2>
<p>Si un hilo puede quedar <strong>bloqueado</strong>  al
ejecutar una operaci√≥n, la documentaci√≥n debe indicar:</p>
<ul>
<li><p><strong>Cu√°ndo los objetos requieren
	sincronizaci√≥n externa</strong></p></li>
<li><p><strong>Qu√© bloqueo es necesario para realizar la
	operaci√≥n</strong></p></li>
</ul>
<p>üìå Importante:</p>
<blockquote>No siempre se
documenta <strong>qui√©n bloquea a qui√©n</strong>,<br/>
sino <strong>qu√©
debe hacer el usuario del objeto</strong>.</blockquote>
<p>Esto explica por qu√©:</p>
<ul>
<li><p>‚ÄúTodas las respuestas son correctas‚Äù era
	<strong>incorrecta</strong></p></li>
<li><p>El corrector esperaba una opci√≥n <strong>concreta</strong></p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1994_1044307265" lang="es">
<strong>7.5. Sincronizaci√≥n interna vs externa</strong></h2>
<h3 lang="es"><strong>Sincronizaci√≥n interna</strong></h3>
<ul>
<li><p>El propio objeto se protege</p></li>
<li><p>M√©todos synchronized</p></li>
<li><p>M√°s segura para el usuario</p></li>
</ul>
<h3 lang="es"><strong>Sincronizaci√≥n externa</strong></h3>
<ul>
<li><p>El usuario del objeto debe sincronizar</p></li>
<li><p>Debe documentarse <strong>expl√≠citamente</strong></p></li>
<li><p>M√°s flexible, pero m√°s peligrosa</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1996_1044307265" lang="es">
<strong>7.6. Dise√±o de clases seguras para hilos</strong></h2>
<p>Una clase bien dise√±ada en multihilo:</p>
<ul>
<li><p>Minimiza estado compartido</p></li>
<li><p>Usa inmutabilidad cuando es posible</p></li>
<li><p>Documenta claramente sus garant√≠as</p></li>
<li><p>No oculta bloqueos inesperados</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc1998_1044307265" lang="es">
<strong>7.7. Errores habituales en dise√±o</strong></h2>
<ul>
<li><p>No documentar bloqueos</p></li>
<li><p>Asumir que el usuario ‚Äúya sabr√°‚Äù sincronizar</p></li>
<li><p>Mezclar operaciones seguras e inseguras</p></li>
<li><p>Usar sincronizaci√≥n innecesaria</p></li>
</ul>
<hr/>
<h1 id="__RefHeading___Toc2000_1044307265" lang="es">
<strong>Unidad 02 ‚Äì Programaci√≥n Multihilo (Resumen
ultra-compacto)</strong></h1>
<hr/>
<h2 id="__RefHeading___Toc2002_1044307265" lang="es">
<strong>1. Concurrencia y conceptos b√°sicos</strong></h2>
<ul>
<li><p><strong>Hilo</strong>: unidad de ejecuci√≥n dentro
	de un proceso.</p></li>
<li><p><strong>Concurrencia</strong>: ejecuci√≥n
	simult√°nea (real o aparente) de varios hilos.</p></li>
<li><p><strong>Thread-safe</strong>: c√≥digo que funciona
	correctamente con varios hilos a la vez.</p></li>
<li><p><strong>Condici√≥n de carrera</strong>: varios
	hilos acceden al mismo recurso y al menos uno escribe.</p></li>
<li><p><strong>Interferencia</strong>: un hilo pisa los
	cambios de otro.</p></li>
<li><p><strong>Operaci√≥n at√≥mica</strong>: se ejecuta
	entera o no se ejecuta.</p></li>
<li><p><strong>Inmutabilidad</strong>: objetos cuyo
	estado no cambia ‚Üí thread-safe por dise√±o.</p></li>
<li><p><strong>Errores de consistencia de memoria</strong>:
	distintos hilos ven valores distintos del mismo dato.</p></li>
<li><p><strong>volatile</strong>:
	garantiza visibilidad, no exclusi√≥n mutua.</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc2004_1044307265" lang="es">
<strong>2. Creaci√≥n y ejecuci√≥n de hilos</strong></h2>
<ul>
<li><p><strong>Clase base</strong>: Thread</p></li>
<li><p><strong>Formas de crear hilos</strong>:</p>
<ul>
<li><p>Heredar de Thread 
		(sobrescribir run() )</p></li>
<li><p>Implementar Runnable</p></li>
<li><p>Implementar Callable 
		(retorna valor, lanza excepciones)</p></li>
</ul>
<li><p><strong>Inicio correcto</strong>: start() 
	(no run() )</p></li>
<li><p><strong>Finalizaci√≥n</strong>: cuando termina
	run()  o call()</p></li>
<li><p><strong>No existen m√©todos seguros para matar
	hilos</strong></p></li>
<li><p><strong>Detenci√≥n correcta</strong>: variable de
	control (cooperativa)</p></li>
<li><p><strong>ThreadGroup</strong>: agrupa hilos
	(obsoleto)</p></li>
</li></ul>
<hr/>
<h2 id="__RefHeading___Toc2006_1044307265" lang="es">
<strong>3. Estados y ciclo de vida</strong></h2>
<p>Estados ( Thread.State ):</p>
<ul>
<li><p><strong>NEW</strong></p></li>
<li><p><strong>RUNNABLE</strong>  (listo o ejecutando)</p></li>
<li><p><strong>BLOCKED</strong></p></li>
<li><p><strong>WAITING</strong></p></li>
<li><p><strong>TIMED_WAITING</strong></p></li>
<li><p><strong>TERMINATED</strong></p></li>
</ul>
<p>Claves:</p>
<ul>
<li><p>start()  ‚Üí NEW ‚Üí
	RUNNABLE</p></li>
<li><p>Desbloqueo ‚Üí RUNNABLE</p></li>
<li><p>Fin de run()  ‚Üí
	TERMINATED</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc2008_1044307265" lang="es">
<strong>4. Memoria y compartici√≥n</strong></h2>
<ul>
<li><p><strong>Stack (pila)</strong>: privada por hilo</p></li>
<li><p><strong>Heap</strong>: compartido</p></li>
<li><p><strong>Variables locales</strong>  ‚Üí stack ‚Üí
	nunca compartidas</p></li>
<li><p><strong>Objetos locales</strong>  ‚Üí heap ‚Üí
	pueden compartirse</p></li>
<li><p><strong>Miembros de objetos</strong>  ‚Üí heap ‚Üí
	compartidos si misma instancia</p></li>
<li><p><strong>static</strong> 
	‚Üí compartidas por todos los hilos</p></li>
<li><p>Problemas aparecen con <strong>estado compartido +
	escritura concurrente</strong></p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc2010_1044307265" lang="es">
<strong>5. Sincronizaci√≥n y monitores</strong></h2>
<ul>
<li><p><strong>Monitor</strong>: entidad interna asociada
	a cada objeto</p></li>
<li><p><strong>synchronized</strong>:</p>
<ul>
<li><p>Exclusi√≥n mutua</p></li>
<li><p>Visibilidad de memoria</p></li>
</ul>
<li><p>Puede aplicarse a:</p>
<ul>
<li><p>M√©todos</p></li>
<li><p>Bloques</p></li>
</ul>
<li><p><strong>No todo thread-safe usa </strong><strong>synchronized</strong></p></li>
<li><p>Problemas posibles:</p>
<ul>
<li><p>Deadlock</p></li>
<li><p>Starvation</p></li>
<li><p>Livelock</p></li>
</ul>
<li><p>En examen:</p>
<ul>
<li><p>Respuestas parciales ‚Üí ‚ÄúNinguna es correcta‚Äù</p></li>
</ul>
</li></li></li></li></ul>
<hr/>
<h2 id="__RefHeading___Toc2012_1044307265" lang="es">
<strong>6. Planificaci√≥n y prioridades</strong></h2>
<ul>
<li><p>Sistemas de <strong>tiempo compartido</strong></p></li>
<li><p>La <strong>JVM no planifica</strong>  (lo hace el
	SO)</p></li>
<li><p>Prioridades:</p>
<ul>
<li><p>Rango: <strong>1‚Äì10</strong></p></li>
<li><p>MIN_PRIORITY  = 1</p></li>
<li><p>NORM_PRIORITY  = 5
		(por defecto)</p></li>
<li><p>MAX_PRIORITY  = 10</p></li>
</ul>
<li><p>La prioridad es <strong>relativa</strong></p></li>
<li><p>Mismo nivel ‚Üí orden impredecible</p></li>
<li><p>No confiar en prioridades para la l√≥gica</p></li>
</li></ul>
<hr/>
<h2 id="__RefHeading___Toc2014_1044307265" lang="es">
<strong>7. Documentaci√≥n y dise√±o multihilo</strong></h2>
<ul>
<li><p>Las operaciones de un objeto provienen de sus
	m√©todos</p></li>
<li><p>Operaciones compuestas ‚Üí alto riesgo</p></li>
<li><p>La documentaci√≥n debe indicar:</p>
<ul>
<li><p>Cu√°ndo se requiere sincronizaci√≥n externa</p></li>
<li><p>Qu√© bloqueo es necesario</p></li>
</ul>
<li><p>Sincronizaci√≥n:</p>
<ul>
<li><p>Interna ‚Üí m√°s segura</p></li>
<li><p>Externa ‚Üí debe documentarse</p></li>
</ul>
<li><p>La documentaci√≥n forma parte de la seguridad</p></li>
</li></li></ul>
<hr/>
<h2 id="__RefHeading___Toc2016_1044307265" lang="es">
<strong>8. M√©todos clave de la clase </strong><strong><code>Thread</code></strong></h2>
<p>Todos pertenecen a Thread:</p>
<ul>
<li><p>run()</p></li>
<li><p>start()</p></li>
<li><p>getId()</p></li>
<li><p>currentThread() 
	(est√°tico)</p></li>
<li><p>sleep()</p></li>
<li><p>join()</p></li>
<li><p>getPriority(),
	setPriority()</p></li>
</ul>
<hr/>
<h2 id="__RefHeading___Toc2018_1044307265" lang="es">
<strong>Ideas clave de examen</strong></h2>
<ul>
<li><p>Local ‚â† seguro (objetos)</p></li>
<li><p>Heap = compartido</p></li>
<li><p>volatile  ‚â†
	synchronized</p></li>
<li><p>No existe DEFAULT_PRIORITY</p></li>
<li><p>No hay m√©todo para ‚Äúdetener‚Äù hilos</p></li>
<li><p>Prioridad no garantiza orden</p></li>
<li><p>Si todas las respuestas son incompletas ‚Üí
	<strong>‚ÄúNinguna es correcta‚Äù</strong></p></li>
</ul>
<hr/>
<p><a href="../../index.html">Volver al √≠ndice</a></p></body>
</html>